Итак - что это такое и с чем это едят

**Здесь находятся автотесты для 40smart**

# Пока в наличии:

-  **Meter DataBase Settings API**
	- [Ссылка на тестовый прогон:](http://helpdesk.allmonitoring.local/secure/Tests.jspa#/testCycle/UM40-C8)
- **Meter DataBase Data API**
	- [Ссылка на тестовый прогон:](http://helpdesk.allmonitoring.local/secure/Tests.jspa#/testPlayer/UM40-C9)
	- В том числе учтено: 
		- Запуск Meter Data в многопоточном режиме
		- Проверка на обработку null значений
- **Meter Devices API**
	- [Ссылка на тестовый прогон:](http://helpdesk.allmonitoring.local/secure/Tests.jspa#/testCycle/UM40-C10)
- **Meter Daemon**
	- [Ссылка на тестовый прогон:]()
	- В том числе учтено: 
		- Запуск Meter Daemon в многопоточном режиме
- **Тесты на проверку Meter db**
  - Тесты на обработку значений поля Records в ArchInfo
    - [Ссылка на тестовый прогон:]()
# Как это запускать :

- Есть прогоны автоматизированных тестов с помощью PyTest с заранее прописанным набором тестовых данных

- Есть возможность запустить в ручном режиме на своей выборке тестовых данных

- Есть возможность запустить свой JSON для определенного компонента

**Подробнее о каждом способе запуска ниже**


# Настройки перед запуском
Для работы тестов необходимо :

- Скачать и установить Python
 	- При написании проекта использовался Python 3.9
- Установить зависимые библиотеки для Python, что сипользуются в проекте(Подробнее - ниже)	
- Прописать настройки в `setting.ini` :
  - Обязательно необходимо прописать путь до БД Meter.db в графе `dbpath`.
  	- Папка в самом диcтрибутиве находиться по пути: `/var/opt/uspd`.
  - Если используется способ соединения `TCP\IP` необходимо заполнить настройки IP адреса`apiaddr` и порт `apiport`
  - Если используется способ соединения `SSH`, то необходимо заполнить поля логина `user_login`, пароля `user_password` и адреса `addres_ssh`
  - Если используется способ соединения `VirtualBox`, то необходимо кроме полей логина и пароля заполнить поля имени машины `machine_name` и имени гостеного домена `domain`


# Зависимости

При написании тестов использовалась стороние библиотеки.
Данные зависимости будут обговорены в начале описания компонента или способа запуска

Ниже приведены **все используемые** в проекте зависимости :

- PyTest
	- Команда чтоб установить :
	```bash
	pip install pytest
	```
- Компонент для генерации HTML отчета для тестов pytest
	- Команда чтоб установить :
	```bash
	pip install pytest-html
	```
- Компонент для запуска тестов pytest в многопоточном режиме (Не работает с компонентами которые работают с БД)
	- Команда чтоб установить :
	```bash
	pip install pytest-xdist
	```
- API для Docker
	- Команда чтоб установить :
	```bash
	pip install docker
	```
- Библиотека для работы по SSH 
	- Команда чтоб установить :
	```bash
	pip install paramiko
	```
- Библиотека для работы с Virtual Box.

	- Команда чтоб установить питоновскую библиотеку :
	```bash
	pip install virtualbox
	```
	
	- Так же для работы этой библиотеки необходимо установить SDK VirtualBox [Ссылка на скачивание SDK](https://download.virtualbox.org/virtualbox/6.1.18/VirtualBoxSDK-6.1.18-142142.zip) . Подробнее описанно в [инструцкции](https://pypi.org/project/virtualbox/)
	

- Библиотека имитатора счетчика уже вшита в проект
- Библиотека Dump уже вшита в проект

# Способы связи с компонентом
Данные тесты можно запускать с параметрами в зависимости от того, где находится дистрибутив с установленым нужным компонетом, тест которого проводится

**Поддержанные способы связи:**

- Запуск через локально запущенный docker контейнер 
- Запуск через гостевую сессию виртуальной машины VirtualBox
- Запуск с помощью соединения по TCP\IP
- Запуск с помощью соединения по SSH
- Запуск внутри linux-системы

### Запуск через запущенный docker контейнер
- Для этого способа необходимо **локально** запустить docker контейнер в котором установлен нужный тестируемый.
- Для работы с этим способом необходима установка модуля API для Docker(Команда указана в разделе Зависимости)
- Скрипт подключится через Docker exec в **первый** запущенный контейнер - и будет взаимодействовать с ним

### Запуск через гостевую виртуальную машину VirtualBox
- Для этого необходимо установить SDK Virtual Box, а после установить необходимую библиотеку
- Прописать в настройках нужные параметры (Указано выше)
- Установить гостевые дополнения в виртуальную машину


### Запуск через SSH
- Необходимо установить нужную библиотеку
- Прописать в настройках нужные параметры (Указано выше)
- Установить сервер SSH и в настройках (`sudo vi /etc/ssh/sshd_config`) прописать доступ по логину-паролю локальной учетной записи
   - Пока используется только стандартный порт : 22

### Запуск через TCP\IP
- Для этого способа надо :
	- Правильно прописать настройки для нашего дистрибутива , где находится компонент в файле `settings.ini`:
		- IP адрес в графе `apiaddr`
		- порт  в графе `apiport` нашего дистрибутива , где находится компонент

	- Прописать нужный компонент в параметрах утилиты inetd самого дистрибутива

### Запуск внутри linux-системы

PS - В этой версии тестов 100% рабочий только способ конекта через локальный Docker-контейнер



# Запуск через PyTest

Для работы запуска тестов через pytest на заранее подготовленном наборе данных необходимо:
(Команды указаны в разделе Зависимости)
- Установить pytest
- Так же для генерации отчетов необходимо установить библиотеку pytest-html

Так же необходимо выбрать способ связи (Способы связи указаны в разделе Способы связи с компонентом )

Далее можно:
- Локально запустить все что есть:
	-- из дириктории тестов запустить команду в cmd ```python -m pytest```

- Локально запустить отдельный файл тестов
	-- из дириктории тестов в cmd

	Пример :

```bash
python -m pytest test_Meter_db_settings_API.py -vv --junitxml=result_test_meter_db_api.xml
```

или
```bash
python -m pytest test_Meter_db_data_API.py -vv --html=report.html
```

### В наличие есть тесты :

- `test_MeterTable_db_API.py`   для  __Meter dataBase API__
- `test_Meter_db_data_API.py`   для  __Meter db data API__
- `test_Meter_devices_API.py`   для  __Meter db devices API__

# Ручной запуск на своем наборе данных
Существует возможность запуска тестов на своем наборе данных
Для этого необходимо :
- Надо импортировать в свой питоновский скрипт файл нужного компонента , который находится в папке `working_directory`
- После этого выбрать класс нужного нам запроса, и метод класса отвечающий за дополнительной настрйоки запроса.
- Если необходимы параметры - Задать и их.

## для Meter db API :

-  файл :  `Meter_db_API.py`
- После этого выбрать класс нужного нам запроса, и метод класса отвечающий за таблицу. Если необходимы параметры - Задать и их.

Пример :

```Python
MeterTable = Meter_db_API.GET().MeterTable(count_get_ids = 0, count_generate_ids = 4)
```
- в данном случае вызываем Get запрос для таблицы  MeterTable .
- Параметры нужны для JSON.
	- Параметр `_count_get_ids_` отвечает сколько будем помещать ID в JSON
	- Параметр `count_generate_ids` отвечает за количесто сгенерированных параметров в самой БД в которой обращаемся.
- Для любителей выстрелить в ногу стоит обработчик , который прервет тест , если параметр не верно был задан
- ВАЖНО : некоторые JSON при не указания конкретного параметра id (delete , get для таблицы MeterTable) выполняют этот метод для всех значений имеющихся в таблице. Данное действие реализуется путем выставления переменной  _count_get_ids_ значения  равному _0_ (ноль)

## для Meter db data API :

- Файл: `Meter_db_data_API.py`
- После этого выбрать класс нужного нам запроса, и метод класса отвечающий за таблицу. Если необходимы параметры - Задать и их.

Пример :

```Python
meterdata = GET().Сustom_measures(list_measure=["ElConfig"],
                                      select_count_ts=2,
                                      select_count_id=2,
                                      generate_count_ts=3,
                                      generate_count_id=3,
                                      count_tags=0,
                                      select_device_idx=True,
                                      select_meter_id=True,
                                      serial=True,
                                      select_id_all=True,
                                      select_last_time=True,
                                      out_of_bounds=False
                                      )
```
В данном случае вызываем Get запрос для параметра ElConfig  .
- Параметры нужны для вариативности формирования JSON. Все  Параметры что используются :

	- `list_measure` - `list`- Переменная, которая представляет из себя массив типов данных что используются.

	- `generate_count_ts` - `int` - Количество отрезков времени , которые генерируем
	- `generate_count_id` - `int` - Количество различных айдишников , которые генерируем
	- `select_count_ts` - `int` - Количество отрезков времени , которые запрашиваем
	- `select_count_id` - `int` - Количество Id которые запрашиваем

	- `count_tags` - `int` или `list` -  Количество тэгов или список тэгов которые попадут в JSON
	- `select_device_idx` - `bool` - Маркер селекта по device_idx - внутрений айдишник
	- `select_meter_id` - `bool` - Маркер селекта по meter_id - внешний айдишник

	- `select_id_all` -  `bool` - Маркер селекта всего что есть. Взаимоисключающий с `select_meter_id`, `select_device_idx и serial`

	- `select_last_time` - `bool` - Маркер селекта последнего времени. Взаимоисключающий с `select_count_ts` и `out_of_bounds`

	- `out_of_bounds` - `bool` - Маркер выхода за границы существующего времени - Важен для настройки лимита времени

	- `serial` - `bool` - Маркер селекта по serial - серийный номер в config

- Для любителей выстрелить в ногу стоит обработчик , который прервет тест , если параметр не верно был задан

## для Meter devices API :
- Файл: `Meter_db_device_API.py`
- После этого выбрать класс нужной реализации и метод отвечающий за способ связи
 	- Класс `JOB` является классом родителем и содержит метод `Setup` который принимает JSON и отдает ответ
	- Класс `RealMeter` является классом для работы с реальным счетчиком (По умолчанию подключается к Энергомере СЕ 303 со стенда ) и содержит методы:
		- `iface_Serial_Port` для работы по серийному порту
		- `iface_Ethernet` для работы по Ethernet
	- Класс `VirtualMeter` является классом для работы с имитатором счетчика (Имитатор счетчика зависимый проект и его надо подтягивать) и содержит методы:
			- `iface_Serial_Port` для работы по серийному порту
			- `iface_Ethernet` для работы по Ethernet

Пример :
```Python
data = VirtualMeter().iface_Ethernet("ElSyncTime")
```
```Python
data = RealMeter(False).iface_Ethernet("ElJrnlPwr")
```
Парамеры запуска :
- Для Конструктора класса :
	- `set_castrom_time` - `bool`  - Булевый маркер возможности задать свой отрезок времени
	Если данный параметр `True`, то можно задавать свой промежуток
		- `start` - `int` -  Начальная дата -  Подаётся в UNIX time
		- `end` - `int` - Конечная дата -  Подаётся в UNIX time
- Для методов класса :
	- job_type str
	iface: str
ipconfig

# Запуск своего JSON и получить JSON ответа

В данный момент функционал работает не стабильно.


# Как это Работает: #  
- Формируется JSON
	- Если для JSON нужны параметры , то они генерируются в нужном количестве - они указываются при формировании JSON
- JSON отправляется, и получаем ответ
- Далее JSON Разбирается
    - Если ответный JSON имеет _res = 0_ , то алгоритм идет дальше. Если нет - то ошибка добавляется в массив и возвращается
- Идет обработка и сравнение полученных данных исходя из данных в БД
- Выдается результат
- Результат представляет собой массив из словарей с конкретной ошибкой, что возникла. Если тесты успешны - то массив пустой.
- Результат обрабатывается с помощью pytest - тест успешен только в случае если массив пустой



## Далее описан общий алгоритм работы по модулям:
Это может понадобится для более детальных тестов и любителям в ручную потыкать.
- Функции запроса к БД лежат в **working_directory** в файле **sqlite.py**
- Для того чтоб подать свой JSON понадобится класс **Setup** который лежит в директории **working_directory.Template.Template_Setup**.
    - В конструктор класса передаем нужный JSON , а после считываем ответ из атрибута класса из поля  **answer_JSON** уже в виде , с которым может что то делать python
    >-- Так же для простоты работы можно использовать файл **Setup.py** ,что лежит в **working_directory** .Oн имеет функцию **setup** , которая принимает JSON и возвращает ответ
- Так же можно воспользооваться конструктором JSON , который находится в файле **Template_JSON_for_Meter_db_API** в директории **working_directory.Template**
	- В этом файле находятся классы типа запросов, конструктор которых прописывает тип запроса , у каждого класса есть методы, которые добавляют значение таблицы в JSON, и отдают его.
	Пример :
    ```
    JSON = Template_JSON_for_Meter_db_API.PUT().ArchInfo(setting={"records" : 11, "type" : "ElConfig"})
    ```
    Это нам сформирует JSON :
    ```
    {"method":"put", "table":"ArchInfo", "settings":[{"records" : 11, "type" : "ElConfig"}]}
    ```

	Если не вытсавить параметры метода,
	Пример:
	 ```
	JSON = Template_JSON_for_Meter_db_API.DELETE().MeterTable()
	 ```
	То отданный словарь-JSON будет без этих ключей:
	```
    {"method":"delete", "table":"MeterTable"}
    ```

- Для конструктора JSON прописан обработчик ключей **settings** и **id** - поскольку они имеют возможность прописываться вручную - обработчик пытается их распознать и подставить правильно:
	- присутствует обратотчик для массива из простых значений , массив из вложенных списков или кортежей , массив из не полных словарей , с последующей их достройкой .
	Например:
  	```  
    JSON = Template_JSON_for_Meter_db_API.PUT().ArchInfo([
                                                        {'records': 4721, 'type': 'ElJrnlLimFreqMax'},
                                            {'records': 8245, 'type': '24344', 'sff':'sfdf','lol':'fof'},
                                                        (2,765),
                                                        [464, 'ElConfig']
                                                        ])
	```
	Отдаст нам корректный JSON :
	```
	{"method":"put", "table":"ArchInfo", "settings":[{"records" : 4721, "type" : "ElJrnlLimFreqMax"},
	                                                 {"records": 8245, "type": "24344"},
	                                                 {"records": 2, "type": "765"},
	                                                 {"records": 464, "type": "ElConfig"},
	                                                                                        ]}
	```
    - Так же поддерживается подача не составного значения

    - Подробнее функции можно посмотреть в файле Template_formation_of_settings.py расположенного в working_directory\Template
- Так же есть генератор уникальных значений , который генерирует нужное нам колличество нужных полей **settings** и **id** - соответственно классы **GeneratorForSettingsMeterTable** и **GeneratorForSettingsArchInfo**, расположенные по пути  working_directory\Template в файлах : **Template_generator_settings_ArchInfo** и **Template_generator_settings_MeterTable** соотвественно.
Эти классы имеют методы которые возвращают нам значения в нужном виде для определенных целей.
	- для GeneratorForSettingsMeterTable :
		 - get_dict - Возвращает массив из словарей settings для этой таблицы
		- get_tuple - Тоже самое что и выше, только ввиде кортежей - необходимо , допустим для загрузки в БД через прямой запрос к БД
		- get_ids - Возвращает массив из ids для этой таблицы, полностью идентичный позициям в settings этого экземпляра класса
		- get_id_to_delete - как и выше умопянутый метод, однако выбирает указанное количество уникальных элементов случайно выбранных из сгенерированных
	- для GeneratorForSettingsArchInfo:
		- get_dict - Возвращает массив из словарей settings для этой таблицы
		- get_dict_without_id - тоже самое что и выше , но только без поля ключа ID
		- get_list_for_db - Список из кортежей для записи в БД

- Директория working_directory\Connect содержит методы и классы для рабоыт с сокетом. Вынес в отдельную папку на всякий случай , так как она не очень будет интересна при ручном тестировании

- Алгоритмы работы  сравнения находятся в классе CheckUP что расположен в директории working_directory.Template.Template_checkup_JSON_from_Meter_db_API
